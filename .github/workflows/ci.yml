name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  release:
    types: [published]

jobs:
  build-and-test:
    if: github.event_name != 'release'
    runs-on: macos-15
    timeout-minutes: 15

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache SPM dependencies
        uses: actions/cache@v4
        with:
          path: |
            .build
            ~/Library/Caches/org.swift.swiftpm
            ~/Library/org.swift.swiftpm
          key: macos-spm-${{ hashFiles('Package.swift', 'Package.resolved') }}
          restore-keys: macos-spm-

      - name: Build (debug)
        run: swift build

      - name: Test
        run: swift test
        timeout-minutes: 10

      - name: Build release and package .app bundle
        run: ./build.sh

      - name: Upload .app artifact
        uses: actions/upload-artifact@v4
        with:
          name: ClaudeUsage.app
          path: ClaudeUsage.app/
          retention-days: 7

  sign-and-notarize:
    needs: build-and-test
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: macos-15
    timeout-minutes: 30

    steps:
      - name: Check signing secrets
        env:
          DEVELOPER_CERT_BASE64: ${{ secrets.DEVELOPER_CERT_BASE64 }}
        run: |
          if [ -z "$DEVELOPER_CERT_BASE64" ]; then
            echo "::notice::Signing secrets not configured — skipping sign-and-notarize job"
            echo "See plans/SIGNING_PLAN.md for setup instructions"
            exit 1
          fi

      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache SPM dependencies
        uses: actions/cache@v4
        with:
          path: |
            .build
            ~/Library/Caches/org.swift.swiftpm
            ~/Library/org.swift.swiftpm
          key: macos-spm-${{ hashFiles('Package.swift', 'Package.resolved') }}
          restore-keys: macos-spm-

      - name: Import code signing certificate
        env:
          DEVELOPER_CERT_BASE64: ${{ secrets.DEVELOPER_CERT_BASE64 }}
          DEVELOPER_CERT_PASSWORD: ${{ secrets.DEVELOPER_CERT_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          CERT_PATH="$RUNNER_TEMP/developer_cert.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          echo -n "$DEVELOPER_CERT_BASE64" | base64 --decode -o "$CERT_PATH"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          security import "$CERT_PATH" \
            -P "$DEVELOPER_CERT_PASSWORD" \
            -A -t cert -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          # Critical: allow codesign to access key without UI prompt
          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Add to search list while preserving existing keychains
          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | tr -d '"')

      - name: Build release and sign
        env:
          DEVELOPER_SIGNING_IDENTITY: ${{ secrets.DEVELOPER_SIGNING_IDENTITY }}
        run: |
          ./build.sh --sign "$DEVELOPER_SIGNING_IDENTITY"

      - name: Verify signature
        run: |
          codesign --verify --deep --strict -vvvv ClaudeUsage.app
          echo "Signature verified successfully"

      - name: Notarize
        env:
          APPSTORE_KEY_BASE64: ${{ secrets.APPSTORE_KEY_BASE64 }}
          APPSTORE_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}
          APPSTORE_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
        run: |
          # Decode API key
          API_KEY_PATH="$RUNNER_TEMP/AuthKey.p8"
          echo -n "$APPSTORE_KEY_BASE64" | base64 --decode -o "$API_KEY_PATH"

          # Create zip with ditto (NOT zip — zip corrupts macOS metadata)
          ditto -c -k --sequesterRsrc --keepParent ClaudeUsage.app ClaudeUsage.zip

          # Submit and wait for Apple to process (typically 2-15 min)
          # Use --output-format json for reliable status parsing
          # Use --timeout to exit gracefully before runner kills the job
          # Capture stdout (JSON) separately from stderr (progress/diagnostics)
          NOTARY_OUTPUT=$(xcrun notarytool submit ClaudeUsage.zip \
            --key "$API_KEY_PATH" \
            --key-id "$APPSTORE_KEY_ID" \
            --issuer "$APPSTORE_ISSUER_ID" \
            --wait \
            --timeout 20m \
            --output-format json 2>"$RUNNER_TEMP/notary_stderr.log")

          echo "$NOTARY_OUTPUT"
          cat "$RUNNER_TEMP/notary_stderr.log" || true

          # Parse status — do not rely on exit code alone
          STATUS=$(echo "$NOTARY_OUTPUT" | python3 -c "import sys,json; print(json.load(sys.stdin).get('status','Unknown'))")

          if [ "$STATUS" != "Accepted" ]; then
              echo "ERROR: Notarization failed with status: $STATUS"
              SUBMISSION_ID=$(echo "$NOTARY_OUTPUT" | python3 -c "import sys,json; print(json.load(sys.stdin).get('id',''))")
              if [ -n "$SUBMISSION_ID" ]; then
                  echo "--- Notarization log ---"
                  xcrun notarytool log "$SUBMISSION_ID" \
                      --key "$API_KEY_PATH" \
                      --key-id "$APPSTORE_KEY_ID" \
                      --issuer "$APPSTORE_ISSUER_ID"
              fi
              exit 1
          fi

          # Staple the ticket to the .app (NOT the zip)
          xcrun stapler staple ClaudeUsage.app

      - name: Verify notarization
        run: |
          xcrun stapler validate ClaudeUsage.app
          spctl -a -vvv -t execute ClaudeUsage.app

      - name: Package signed app
        run: |
          # Create zip with ditto to preserve code signature and extended attributes
          # (actions/upload-artifact's internal zip strips macOS metadata)
          ditto -c -k --sequesterRsrc --keepParent ClaudeUsage.app ClaudeUsage-signed.zip

      - name: Upload signed app
        uses: actions/upload-artifact@v4
        with:
          name: ClaudeUsage-signed
          path: ClaudeUsage-signed.zip
          retention-days: 30

      - name: Clean up signing artifacts
        if: ${{ always() }}
        run: |
          security delete-keychain "$RUNNER_TEMP/app-signing.keychain-db" || true
          rm -f "$RUNNER_TEMP/developer_cert.p12"
          rm -f "$RUNNER_TEMP/AuthKey.p8"

  # Release job — triggers on GitHub Release creation (tag must be v#.#.#)
  # Stamps version, builds, signs, notarizes, and uploads zip to the release.
  # Signing/notarization steps kept in sync with sign-and-notarize job above.
  release:
    if: github.event_name == 'release'
    runs-on: macos-15
    timeout-minutes: 30
    permissions:
      contents: write
    concurrency:
      group: release-${{ github.ref }}
      cancel-in-progress: false

    steps:
      - name: Validate tag format
        run: |
          TAG="${GITHUB_REF_NAME}"
          if [[ ! "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "ERROR: Tag '$TAG' does not match required format v#.#.# (e.g. v1.2.3)"
            echo "CFBundleVersion requires dot-separated integers — pre-release suffixes are not allowed."
            exit 1
          fi
          echo "Tag format OK: $TAG"

      - name: Checkout
        uses: actions/checkout@v4

      - name: Stamp version from tag
        run: |
          VERSION="${GITHUB_REF_NAME#v}"
          echo "Stamping version: $VERSION"
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" Resources/Info.plist
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $VERSION" Resources/Info.plist
          /usr/libexec/PlistBuddy -c "Print" Resources/Info.plist

      - name: Cache SPM dependencies
        uses: actions/cache@v4
        with:
          path: |
            .build
            ~/Library/Caches/org.swift.swiftpm
            ~/Library/org.swift.swiftpm
          key: macos-spm-${{ hashFiles('Package.swift', 'Package.resolved') }}
          restore-keys: macos-spm-

      - name: Build (debug) and test
        run: |
          swift build
          swift test
        timeout-minutes: 10

      - name: Check signing secrets
        env:
          DEVELOPER_CERT_BASE64: ${{ secrets.DEVELOPER_CERT_BASE64 }}
        run: |
          if [ -z "$DEVELOPER_CERT_BASE64" ]; then
            echo "::error::Signing secrets not configured — cannot create release"
            exit 1
          fi

      - name: Import code signing certificate
        env:
          DEVELOPER_CERT_BASE64: ${{ secrets.DEVELOPER_CERT_BASE64 }}
          DEVELOPER_CERT_PASSWORD: ${{ secrets.DEVELOPER_CERT_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          CERT_PATH="$RUNNER_TEMP/developer_cert.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          echo -n "$DEVELOPER_CERT_BASE64" | base64 --decode -o "$CERT_PATH"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          security import "$CERT_PATH" \
            -P "$DEVELOPER_CERT_PASSWORD" \
            -A -t cert -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | tr -d '"')

      - name: Build release and sign
        env:
          DEVELOPER_SIGNING_IDENTITY: ${{ secrets.DEVELOPER_SIGNING_IDENTITY }}
        run: |
          ./build.sh --sign "$DEVELOPER_SIGNING_IDENTITY"

      - name: Verify signature
        run: |
          codesign --verify --deep --strict -vvvv ClaudeUsage.app
          echo "Signature verified successfully"

      - name: Notarize and staple
        env:
          APPSTORE_KEY_BASE64: ${{ secrets.APPSTORE_KEY_BASE64 }}
          APPSTORE_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}
          APPSTORE_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
        run: |
          API_KEY_PATH="$RUNNER_TEMP/AuthKey.p8"
          echo -n "$APPSTORE_KEY_BASE64" | base64 --decode -o "$API_KEY_PATH"

          ditto -c -k --sequesterRsrc --keepParent ClaudeUsage.app ClaudeUsage.zip

          NOTARY_OUTPUT=$(xcrun notarytool submit ClaudeUsage.zip \
            --key "$API_KEY_PATH" \
            --key-id "$APPSTORE_KEY_ID" \
            --issuer "$APPSTORE_ISSUER_ID" \
            --wait \
            --timeout 20m \
            --output-format json 2>"$RUNNER_TEMP/notary_stderr.log")

          echo "$NOTARY_OUTPUT"
          cat "$RUNNER_TEMP/notary_stderr.log" || true

          STATUS=$(echo "$NOTARY_OUTPUT" | python3 -c "import sys,json; print(json.load(sys.stdin).get('status','Unknown'))")

          if [ "$STATUS" != "Accepted" ]; then
              echo "ERROR: Notarization failed with status: $STATUS"
              SUBMISSION_ID=$(echo "$NOTARY_OUTPUT" | python3 -c "import sys,json; print(json.load(sys.stdin).get('id',''))")
              if [ -n "$SUBMISSION_ID" ]; then
                  echo "--- Notarization log ---"
                  xcrun notarytool log "$SUBMISSION_ID" \
                      --key "$API_KEY_PATH" \
                      --key-id "$APPSTORE_KEY_ID" \
                      --issuer "$APPSTORE_ISSUER_ID"
              fi
              exit 1
          fi

          xcrun stapler staple ClaudeUsage.app

      - name: Verify notarization
        run: |
          xcrun stapler validate ClaudeUsage.app
          spctl -a -vvv -t execute ClaudeUsage.app

      - name: Package and upload to release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="${GITHUB_REF_NAME}"

          # Create final zip with ditto (preserves code signature and macOS metadata)
          ditto -c -k --sequesterRsrc --keepParent ClaudeUsage.app "ClaudeUsage-${TAG}.zip"

          # Generate checksum
          shasum -a 256 "ClaudeUsage-${TAG}.zip" > "ClaudeUsage-${TAG}.zip.sha256"
          echo "SHA-256:"
          cat "ClaudeUsage-${TAG}.zip.sha256"

          # Upload to GitHub Release
          gh release upload "$TAG" \
            "ClaudeUsage-${TAG}.zip" \
            "ClaudeUsage-${TAG}.zip.sha256" \
            --clobber

      - name: Clean up signing artifacts
        if: ${{ always() }}
        run: |
          security delete-keychain "$RUNNER_TEMP/app-signing.keychain-db" || true
          rm -f "$RUNNER_TEMP/developer_cert.p12"
          rm -f "$RUNNER_TEMP/AuthKey.p8"
